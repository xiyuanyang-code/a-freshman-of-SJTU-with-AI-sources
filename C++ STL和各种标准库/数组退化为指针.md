# 数组退化为指针

在C和C++中，数组在某些情况下会退化为指针，但并不是在所有情况下都会发生这种情况。具体来说，数组在作为函数参数传递时，会退化为指向数组首元素的指针。

以下是一些具体的情况：

1. **函数参数**：
   当你将一个数组作为参数传递给函数时，数组会退化为指向首元素的指针。例如：
   ```c
   void foo(int arr[]) {
       // arr 被视为 int* 类型的指针
   }
   
   int main() {
       int myArray[10];
       foo(myArray); // 这里 myArray 退化为指向首元素的指针
       return 0;
   }
   ```

2. **sizeof 操作符**：
   在函数内部，如果使用 `sizeof` 操作符来计算数组的大小，你会得到指针的大小而不是数组的大小。例如：
   ```c
   void foo(int arr[]) {
       printf("%zu\n", sizeof(arr)); // 输出的是指针的大小，而不是数组的大小
   }
   
   int main() {
       int myArray[10];
       printf("%zu\n", sizeof(myArray)); // 输出的是数组的大小
       foo(myArray);
       return 0;
   }
   ```

   使用`array`库就可以实现输出数组长度（在函数体内部）

3. **数组名作为表达式**：
   在大多数表达式中，数组名会退化为指向数组首元素的指针。例如：

   ```c
   int myArray[10];
   int *ptr = myArray; // myArray 退化为指向首元素的指针
   ```

但是，在以下情况下，数组不会退化为指针：

1. **使用 `sizeof` 操作符**：
   在数组定义的作用域内使用 `sizeof` 操作符时，得到的是数组的总大小，而不是指针的大小。
   ```c
   int myArray[10];
   printf("%zu\n", sizeof(myArray)); // 输出的是数组的大小
   ```

2. **使用 `&` 操作符**：
   使用取地址操作符 `&` 时，得到的是数组的地址，而不是数组首元素的地址。
   ```c
   int myArray[10];
   int (*ptr)[10] = &myArray; // ptr 是指向包含 10 个整数的数组的指针
   ```

总之，数组在某些上下文中会退化为指针，但在其他上下文中不会。了解这些细微差别对于正确使用数组和指针非常重要。